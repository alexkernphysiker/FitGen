Genetic algorithm for fitting and solving equations (C++11)
===========================================================
This repository contains the source code of the library, examples and unit tests


Compiling
=========
If you have your git repository with cmake project you can add a submodule

	git submodule add https://github.com/alexkernphysiker/FitGen.git
	git submodule update --init --recursive

Then add to CMakeLists.txt

	add_subdirectory(FitGen)
	include_directories(${FITGEN_INC})

Then commit your changes :)


Examples
========

	Example/exact_equation.cpp
example of using genetic algorithm for solving equation F(x,y)=G(x,y).

	Example/fit_one_func.cpp 
	Example/fit_foreground_background.cpp
examples of using genetic algorithm for fitting points with function.
For plotting the results, the examples require gnuplot installed.



Short developers guide
======================
All stuff is declared in header files that are located in 'include' directory

	Genetic/paramset.h
Contains class 'ParamSet' that is wrapper over vector<double> used in this library.
	
	Genetic/abstract.h
Contains the declaration of abstract class 'AbstractGenetic' representing the genetic algorithm
and several interfaces that it uses.

'IInitialConditions' represents the rules of initial filling of the population of points in parameters space.

'IParamCheck' represents the rules of checking the parameters validity.
'Filter' is the simplest implementation of this interface that requires function<bool(const ParamSet&)>.

'IOptimalityFunction' represents the algorithm of calculating the optimality of the parameters.
'OptimalityFunction' is the simplest implementation of this interface that requires function<double(const ParamSet&)>.
The lesser the value it returns the more optimal the parameters are concidered.

The typical scenario of using any genetic algorithm is the following:

1) Create an instance of genetic algorithm

2) Call SetFilter(...) method and give the rules of checking parameters validity (optional)

3) Define the count of threads for calculating via SetThreadCount(...) method (optional)

4) create a variable of 'RANDOM' type for using in two next stages

5) Call Init(...) method giving the instance of IInitialConditions and the amount of points in population (obligatory)

6) Provide cycle with appropriate exit condition and call Iterate(...) method inside it. 
   Eventually you can provide some monitoring

7) Get the parameters of the final population state using available public const methods
	
	Genetic/genetic.h 
Set of template classes that provide different kinds of mutations. 
Each template has one parameter that means parent class.
In such way, one can create a class providing needed chain of mutations.
They all have dfault constructors and the mutation parameters are set via special methods.
The list of classes and provided mutations is the following:

1) DifferentialMutations<...>:  P'[i]=P[i]+M*(A[i]-B[i]), where M is a 
  parameter and A,B are random points from population.
  The most recommended is using this type of mutation.

2) Crossing<...>: There's a probability rho of the following process: 
  there would be found random other point X from the population and 
  P'[i]=(random(0..1)>0.5)?P[i]:X[i]

3) AbsoluteMutations<...>: P'[i]=P[i]+RandomGauss(M[i]), where M is 
  a ParamSet of sigmas for the gauss random bluring.

4) RelativeMutations<...>:  P'[i]=P[i]*(1+RandomGauss(M[i]))

5) ExactCopying<...>: there's a probability of cancellation of all inherited mutations.


	Genetic/initialcondition.h 
Contains classes representing the rules of generating the initial points population.
All these classes are applicable via shared_ptr. All they have empty constructors and
have operator<< defined over shared_ptr<these classes> that implement adding rules
for each parameter from generated ParamSet.
The more rules are added to the generator the more parameters have generated ParamSet's.


'InitialDistributions' accepts via << operator instances of MathTemplates::RandomValueGenerator<double> 
defined in submodule (math_h). 
Generates ParamSet's with each element generated by corresponding RandomValueGenerator.

'GenerateUniform' accepts via << operator instances of pair<double,double> that are processed as ranges
of uniform distributions for each parameter of generated ParamSet

'GenerateByGauss' also takes pair<double,double> via << operator but processes them as average and dispersion
of gaussian distributions for each parameter of generated ParamSet.

	
	Genetic/filter.h 
Contains classes implementing different rules of checking the validity of points in population.
All these classes are applicable via shared_ptr. All they have empty constructors and
have operator<< defined over shared_ptr<these classes> that implement adding rules
for each parameter. For simpler checking use class 'Filter' defined in abstract.h

'Above' accepts double values via << operator and checks if the parameter with index corresponding to
the order of added number is greater than the number. Adding INFINITY means skipping the parameter.

'Below' has the same interface but validates ParamSet if all parameters are less that corresponding numbers.

'And' and 'Or' provide logical operations over set of filters that are accepted via << operator.


	Genetic/equation.h 
'EquationSystem' is a class representing a system of equations that have a function defined on ParamSet in the left part and a number in the right part.
'EquationSolver' is a class inheritting 'AbstractGenetic' that finds the most optimal ParamSet for such system of equations.


	Genetic/equation2.h 
'InexactEquationSystem' is a class representing a system of equations that have a function defined on ParamSet in the left part and a magnitude with uncertainty in the right part. 
'InexactEquationSolver' is a class inheritting 'AbstractGenetic' that finds the most optimal ParamSet for such system of equations.

	Genetic/fit.h 
classes needed for fitting points by parametric function

'IParamFunc' provides an interface of parametric function.
It has two parameters: ParamSet X and ParamSet P. The first one means measured parameters the function depends on.
The second one means fitted parameters function depends on.
'ParameterFunction' is the simplest implementation of this interface taking corresponding std::function<...>.
Other implementations are declared in paramfunc.h

'FitPoints' represents the set of fitted points. It's a container of 'Point' instances.
'Point' represents the point as union of ParamSet X and double value Y that can have their uncertainties.
'FitPoints' has operator<< for adding 'Point' instances.
There are more << operators defined over std::shared_ptr<FitPoints> for adding point from MathTemplates::point<double>
that is declares in the submodule (math_h). 
Default constructor of 'FitPoints' creates empty set of points but there are different constructors for
creating set of points from mathematical primitives declared in the submodule (math_h).

'Fit' is template class for fitting points with function (recommended).
The template parameters are the following: parrent class from genetic.h providing mutations and function providing optimality criterium.
The last one has the following variants: SumSquareDiff, ChiSquare, ChiSquareWithXError e.t.c.
The constructor requires instance of 'FitPoints' and instance of IParamFunc describing the fitting function.

'FitFunction' is also a template class for fitting points with function.
The template parameters are the following: parrent class from genetic.h providing mutations, 
type inheritting IParamFunc in the role of function and function of optimality criterium (as in previous example).
The constructor requires instance of 'FitPoints'.
	
	Genetic/paramfunc.h 
template classes providing parametric functions for fitting algorithm (inheritting 'IParamFunc')
Please view example fit_points.cpp to see how they are used


Tests
=====

	tests/*.cpp
The directory tests contains cmake project with unit tests.
The tests require GoogleTest framework to be installed

CMake Options
=============

	tests
if ON the tests are compiled
